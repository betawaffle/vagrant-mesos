# -*- mode: ruby -*-
# vi: set ft=ruby :
require 'yaml'
require './lib/gen_node_infos'
require './lib/predicates'

base_dir = File.expand_path(File.dirname(__FILE__))
conf     = YAML.load_file(File.join(base_dir, 'cluster.yml'))
ninfos   = gen_node_infos(conf)
ami      = YAML.load_file(File.join(base_dir, 'scripts', 'aws_region_ami.yaml'))

unless ninfos[:zk].empty?
  zk_endpoints = ninfos[:zk].map{ |zk| zk[:ip]+':2181' }.join(',')
end

SET_HOSTNAME = <<-SCRIPT
  PUBLIC_DNS=`wget -q -O - http://169.254.169.254/latest/meta-data/public-hostname`
  hostname $PUBLIC_DNS
  echo $PUBLIC_DNS > /etc/hostname
  HOSTNAME=$PUBLIC_DNS  # Fix the bash built-in hostname variable too
SCRIPT

## vagrant plugins required:
# vagrant-aws, vagrant-berkshelf, vagrant-omnibus, vagrant-hosts, vagrant-cachier
Vagrant.configure('2') do |config|

  # enable plugins
  config.berkshelf.enabled = true
  config.omnibus.chef_version = :latest
  config.cache.auto_detect = true

  config.vm.provider :virtualbox do |vb, override|
    override.vm.box = 'Official Ubuntu 13.04 daily Cloud Image amd64 (No Guest Additions)'
    override.vm.box_url = 'http://cloud-images.ubuntu.com/vagrant/raring/current/raring-server-cloudimg-amd64-vagrant-disk1.box'

    override.vm.provision :hosts
    override.vm.provision :shell, path: 'scripts/populate_sshkey.sh', args: '/root root'
    override.vm.provision :shell, path: 'scripts/populate_sshkey.sh', args: '/home/vagrant vagrant'
  end

  config.vm.provider :aws do |aws, override|
    override.vm.box = 'dummy'
    override.vm.box_url = 'https://github.com/mitchellh/vagrant-aws/raw/master/dummy.box'

    aws.access_key_id = conf['access_key_id']
    aws.secret_access_key = conf['secret_access_key']
    aws.region = region = conf['region']
    aws.ami = ami[region]
    aws.keypair_name = conf['keypair_name']
    aws.subnet_id = conf['subnet_id']
    aws.security_groups = conf['security_groups']
    aws.associate_public_ip = true

    override.ssh.username = 'ubuntu'
    override.ssh.private_key_path = conf['ssh_private_key_path']

    override.vm.provision :shell, inline: SET_HOSTNAME
    override.vm.provision :shell, path: 'scripts/populate_sshkey.sh', args: '/home/ubuntu ubuntu'
  end

  # define VMs. all VMs has identical configuration.
  [ninfos[:zk], ninfos[:master], ninfos[:slave]].flatten.each_with_index do |ninfo, i|
    name = ninfo[:hostname]
    config.vm.define name do |cfg|
      cfg.vm.provider :virtualbox do |vb, override|
        override.vm.hostname = name
        override.vm.network :private_network, ip: ninfo[:ip]

        vb.name = "vagrant-mesos-#{name}"
        vb.customize ['modifyvm', :id, '--memory', ninfo[:mem], '--cpus', ninfo[:cpus]]
      end

      cfg.vm.provider :aws do |aws, override|
        aws.instance_type      = ninfo[:instance_type]
        aws.private_ip_address = ninfo[:ip]
        aws.tags = {
          Name: "vagrant-mesos-#{name}"
        }

        case name
        when /^master/
          override.vm.provision :shell, inline: 'restart mesos-master'
        when /^slave/
          override.vm.provision :shell, inline: 'restart mesos-slave'
        end
      end

      cfg.vm.provision :chef_solo do |chef|
        chef.add_recipe 'apt'
        chef.add_recipe 'mesos'

        mesos_conf = {
          type: 'mesosphere',
          version: conf['mesos_version']
        }

        case ninfo[:hostname]
        when /^master/
          chef.add_recipe 'mesos::master'

          master_conf = { cluster: conf['cluster_name'], ip: "#{ninfo[:ip]}" }
          master_conf[:zk] = "zk://#{zk_endpoints}/mesos" if zk_endpoints

          mesos_conf[:master]     = master_conf
          mesos_conf[:master_ips] = ninfos[:master].map { |m| "#{m[:ip]}" }
          mesos_conf[:slave_ips]  = ninfos[:slave].map  { |s| "#{s[:ip]}" }
        when /^slave/
          chef.add_recipe 'docker::aufs'
          chef.add_recipe 'docker::lxc'
          chef.add_recipe 'docker'
          chef.add_recipe 'mesos::slave'
          chef.add_recipe 'mesos::docker-executor'

          mesos_conf[:slave] = {
            master: zk_endpoints ? "zk://#{zk_endpoints}/mesos" : "#{ninfos[:master][0][:ip]}:5050",
            ip: "#{ninfo[:ip]}",
            isolation: 'process'
          }
        when /^zk/
          mesos_conf[:mesosphere] = { with_zookeeper: true }
        end

        chef.json = { mesos: mesos_conf }
      end

      case ninfo[:hostname]
      when /^zk([0-9]+)/
        myid = $1
        cfg.vm.provision :shell, inline: <<-SCRIPT
          sudo mkdir -p /tmp/zookeeper
          sudo chmod 755 /tmp/zookeeper
          sudo chown zookeeper /tmp/zookeeper
          sudo -u zookeeper echo #{myid} > /tmp/zookeeper/myid
          sudo -u zookeeper /opt/chef/embedded/bin/ruby /vagrant/scripts/gen_zoo_conf.rb > /etc/zookeeper/conf/zoo.cfg
          sudo restart zookeeper
        SCRIPT
      end
    end
  end

  config.vm.define :marathon do |cfg|
    marathon_ip = "#{conf['marathon_ipbase']}11"

    cfg.vm.provider :virtualbox do |vb, override|
      override.vm.hostname = 'marathon'
      override.vm.network :private_network, ip: marathon_ip

      vb.name = 'vagrant-mesos-marathon'
      vb.customize ['modifyvm', :id, '--memory', conf['marathon_mem'], '--cpus', conf['marathon_cpus']]
    end

    cfg.vm.provider :aws do |aws, override|
      aws.instance_type = conf['marathon_instance_type']
      aws.private_ip_address  = marathon_ip
      aws.tags = {
        Name: 'vagrant-mesos-marathon'
      }
    end

    cfg.vm.provision :chef_solo do |chef|
      chef.add_recipe 'apt'
      chef.add_recipe 'mesos'

      mesos_conf = {
        type: 'mesosphere',
        version: conf['mesos_version']
      }

      chef.json = { mesos: mesos_conf }
    end

    cfg.vm.provision :shell, inline: <<-SCRIPT
      apt-get -y install default-jre-headless unzip curl libcurl3
      if [ ! -e /tmp/marathon.tgz ]; then
        curl -sSfL http://downloads.mesosphere.io/marathon/marathon-0.4.1.tgz --output /tmp/marathon.tgz
        mkdir -p /opt && cd /opt && tar xzf /tmp/marathon.tgz
      fi
      if [ ! -e /tmp/chronos.tgz ]; then
        curl -sSfL http://downloads.mesosphere.io/chronos/chronos-2.1.0_mesos-0.14.0-rc4.tgz --output /tmp/chronos.tgz
        mkdir -p /opt && cd /opt && tar xzf /tmp/chronos.tgz
      fi
      kill -KILL `ps augwx | grep marathon | tr -s " " | cut -d' ' -f2`
      LIBPROCESS_IP=#{marathon_ip} nohup /opt/marathon/bin/start --master zk://#{zk_endpoints}/mesos --zk_hosts #{zk_endpoints} > /opt/marathon/nohup.log 2> /opt/marathon/nohup.log < /dev/null &
      echo 'zk://#{zk_endpoints}/mesos' > /etc/mesos/zk
      nohup /opt/chronos/bin/chronos-marathon > /opt/chronos/nohup.log 2> /opt/chronos/nohup.log < /dev/null &
    SCRIPT
  end if conf['marathon_enable']
end
